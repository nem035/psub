function _assertValidTopic(a){if('string'!=typeof a||0===a.length)throw new TypeError('Topic must be a non empty string')}function _assertValidTopicAndHandler(a,b){if(_assertValidTopic(a),'function'!=typeof b)throw new TypeError('Handler must be a function.')}function _assertSymbol(a){if('symbol'!=typeof a)throw new TypeError('Argument must be a symbol')}class Subscription{constructor({symbol:a,handler:b,duration:c}){if('number'!=typeof c||1>c)throw new TypeError('Duration must by a number > 0');this.symbol=a,this.duration=c,this.handler=b}}const topicToSubscriptionsMap=Symbol('topicToSubscriptionsMap');class PubSub{constructor(){this[topicToSubscriptionsMap]=new Map}subscribe(a,b,c=1/0){_assertValidTopicAndHandler(a,b),this[topicToSubscriptionsMap].has(a)||this[topicToSubscriptionsMap].set(a,[]);const d=Symbol(a),e=new Subscription({symbol:d,handler:b,duration:c});return this[topicToSubscriptionsMap].get(a).push(e),d}publish(a,...b){_assertValidTopic(a);const c=this[topicToSubscriptionsMap].get(a);return c&&0!==c.length&&(c.forEach(d=>{0<d.duration?(d.handler(...b),d.duration-=1):this.unsubscribeHandler(a,d.handler)}),!0)}unsubscribe(...a){if(1===a.length)return this.unsubscribeSymbol(a[0]);if(2===a.length)return this.unsubscribeHandler(a[0],a[1]);throw new TypeError('Must pass 1 or 2 arguments')}unsubscribeSymbol(a){_assertSymbol(a);for(const[b,c]of this[topicToSubscriptionsMap].entries())for(const[d,e]of c.entries())if(e.symbol===a)return c.splice(d,1),!0;return!1}unsubscribeHandler(a,b){if(_assertValidTopicAndHandler(a,b),!this[topicToSubscriptionsMap].has(a))return!1;const c=this[topicToSubscriptionsMap].get(a);for(const[d,e]of c.entries())if(e.handler===b)return c.splice(d,1),!0;return!1}}
